<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <title>Scanlines Mobile ‚Äî points (qualit√© optimis√©e)</title>
  <style>
    :root{--gap:10px;--ui:#111;--card:#1a1a1a}
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:#000;color:#fff;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #wrap{display:flex;flex-direction:column;min-height:100dvh}
    #controls{height:34vh;overflow:auto;background:var(--ui);padding:var(--gap);display:flex;flex-wrap:wrap;gap:var(--gap);justify-content:center;align-content:flex-start}
    .card{background:var(--card);border-radius:12px;padding:8px;display:flex;flex-direction:column;align-items:center;gap:6px}
    .row{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center}
    label{font-size:12px;opacity:.9}
    input[type="range"]{width:120px}
    button,.chip{background:#222;color:#fff;border:1px solid #333;border-radius:10px;padding:8px 12px;font-size:14px}
    .chip{display:inline-flex;gap:8px;align-items:center}
    #stage{height:66vh;display:flex;align-items:center;justify-content:center;background:#000;position:relative}
    /* Important: don't force canvas height:100% to avoid CSS stretching; rely on resizeCanvas */
    canvas{max-width:100%;height:auto;display:block}
    #msg{position:absolute;color:#bbb;left:10px;bottom:10px;font-size:12px;max-width:80%}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js" integrity="sha512-3uBrm3mPi6XvUstl2f+F3H+j2W2gZ0TzQJ4P3uHkzvW9w63a8kGGtRRuQe6o7K9V1q8c0mJUM4J9P9m4+N1Jxw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
</head>
<body>
<div id="wrap">
  <!-- MENU / CONTROLS -->
  <div id="controls">
    <div class="row" style="width:100%;justify-content:center">
      <span class="chip">Source :
        <label><input type="radio" name="src" id="srcCam"> Cam√©ra</label>
        <label><input type="radio" name="src" id="srcImg" checked> Image</label>
      </span>
      <button id="startCamBtn">üé• Activer la cam√©ra</button>
      <label class="chip">üì∑ Charger une image<input id="fileInput" type="file" accept="image/*" style="display:none"></label>
      <button id="saveBtn">üì∏ Enregistrer</button>
      <label class="chip"><input type="checkbox" id="animate"> üéûÔ∏è Animation</label>
      <label class="chip"><input type="checkbox" id="negative"> üåì N√©gatif</label>
      <span class="chip">Palette :
        <label><input type="checkbox" id="cR" checked> Rouge</label>
        <label><input type="checkbox" id="cV"> Vert</label>
        <label><input type="checkbox" id="cB"> Bleu</label>
        <label><input type="checkbox" id="cJ"> Jaune</label>
      </span>
    </div>
    <div class="row">
      <div class="card"><label>Contraste</label><input id="contrast" type="range" min="0" max="255" value="110"></div>
      <div class="card"><label>Intensit√©</label><input id="intensity" type="range" min="0" max="20" step="0.1" value="6"></div>
      <div class="card"><label>Sensibilit√©</label><input id="sensitivity" type="range" min="0.1" max="10" step="0.1" value="1.2"></div>
      <div class="card"><label>D√©tail</label><input id="detail" type="range" min="1" max="8" value="2"></div>
      <div class="card"><label>√âpaisseur</label><input id="stroke" type="range" min="0.5" max="8" step="0.1" value="1.2"></div>
      <div class="card"><label>Rouge</label><input id="red" type="range" min="0" max="1" step="0.01" value="0.2126"></div>
      <div class="card"><label>Vert</label><input id="green" type="range" min="0" max="1" step="0.01" value="0.7152"></div>
      <div class="card"><label>Bleu</label><input id="blue" type="range" min="0" max="1" step="0.01" value="0.0722"></div>
      <div class="card"><label>Points (fix√© √† 1)</label><input id="points" type="range" min="1" max="1" step="1" value="1" disabled></div>
      <div class="card"><label>Diagonale</label><input id="diagonal" type="range" min="0" max="1" step="0.01" value="0"></div>
      <div class="card"><label>Circulaire</label><input id="circular" type="range" min="0" max="1" step="0.01" value="0"></div>
    </div>
  </div>

  <!-- IMAGE ZONE -->
  <div id="stage"><div id="msg"></div><canvas id="defaultCanvas0" class="p5Canvas"></canvas></div>
</div>

<script>
  let cam=null, img=null, imgScaled=null;
  let useCamera = false; // start in Image mode
  let facing = "user";   // desktop: default to 'user' to avoid OverconstrainedError
  let animate=false, negative=false, animationOffset=0;
  const ui={};

  const CAM_TARGET = { w: 640, h: 480 };
  const IMG_MAX   = { w: 1280, h: 960 }; // allow bigger uploads on desktop
  const el = id => document.getElementById(id);
  const msg = (t)=>{ el('msg').textContent = t||''; };

  // Try p5.createCapture with progressively relaxed constraints
  function startCamera(){
    // Clean previous
    if (cam){ cam.remove(); cam=null; }
    let attempts = [
      { video: { facingMode: { exact: facing }, width: {ideal:CAM_TARGET.w}, height:{ideal:CAM_TARGET.h} }, audio:false },
      { video: { facingMode: facing,             width: {ideal:CAM_TARGET.w}, height:{ideal:CAM_TARGET.h} }, audio:false },
      { video: { width: {ideal:CAM_TARGET.w}, height:{ideal:CAM_TARGET.h} }, audio:false },
      { video: true, audio:false }
    ];
    let success = false, lastErr = null;
    (function tryNext(i){
      if (i>=attempts.length){
        msg('Cam√©ra indisponible : '+ (lastErr && lastErr.message ? lastErr.message : lastErr || ''));
        useCamera = false; el('srcCam').checked=false; el('srcImg').checked=true;
        return;
      }
      try {
        cam = createCapture(attempts[i], ()=>{
          // on success (callback after stream starts)
          cam.elt.setAttribute('playsinline','');
          cam.elt.muted = true;
          cam.size(CAM_TARGET.w, CAM_TARGET.h);
          cam.hide();
          useCamera = true;
          el('srcCam').checked = true;
          el('srcImg').checked = false;
          msg('Cam√©ra active.');
        });
        // If it errors asynchronously, capture it:
        cam.elt.onloadedmetadata = ()=>{ /* ok */ };
        cam.elt.onerror = (e)=>{ lastErr = e; cam.remove(); cam=null; tryNext(i+1); };
      } catch(e){
        lastErr = e; tryNext(i+1);
      }
    })(0);
  }

  function resampleImage(source){
    // Keep ratio, downscale if needed to keep perf; object URLs are fine in p5
    const ratio = Math.min(IMG_MAX.w / source.width, IMG_MAX.h / source.height, 1);
    const w = Math.max(1, Math.floor(source.width * ratio));
    const h = Math.max(1, Math.floor(source.height * ratio));
    const g = createGraphics(w, h);
    g.image(source, 0, 0, w, h);
    return g.get();
  }

  function fitCanvasToStage(){
    const stage = el('stage');
    const maxW = stage.clientWidth;
    const maxH = stage.clientHeight;

    let sw = 4, sh = 3;
    if (useCamera && cam && cam.width && cam.height){ sw = cam.width; sh = cam.height; }
    else if (!useCamera && (imgScaled || img)){
      const s = imgScaled || img; sw = s.width; sh = s.height;
    }
    const aspect = sw / sh;

    let targetW = maxW;
    let targetH = Math.round(maxW / aspect);
    if (targetH > maxH){ targetH = maxH; targetW = Math.round(maxH * aspect); }

    if (width !== targetW || height !== targetH){
      resizeCanvas(targetW, targetH, false);
    }
  }

  function setup(){
    pixelDensity(1);
    const stage = el('stage');
    const c = createCanvas(stage.clientWidth, stage.clientHeight);
    c.parent('stage');
    background(0);

    // Bind UI
    ['contrast','intensity','sensitivity','detail','stroke','red','green','blue','points','diagonal','circular'].forEach(id=>ui[id]=el(id));
    el('saveBtn').onclick = ()=>saveCanvas('scan_mobile_points','png');
    el('animate').onchange = e=> animate=e.target.checked;
    el('negative').onchange = e=> negative=e.target.checked;

    // Source selection
    el('srcCam').onchange = e=>{ if(e.target.checked){ startCamera(); } };
    el('srcImg').onchange = e=>{ if(e.target.checked){ useCamera=false; if(cam){cam.remove(); cam=null;} msg(''); } };
    el('startCamBtn').onclick = ()=>{ startCamera(); };

    // Image upload
    el('fileInput').onchange = (e)=>{
      const f = e.target.files && e.target.files[0]; if(!f){ return; }
      const url = URL.createObjectURL(f);
      loadImage(url,
        i=>{ img=i; imgScaled=resampleImage(img); el('srcImg').checked=true; el('srcCam').checked=false; useCamera=false; msg('Image charg√©e.'); fitCanvasToStage(); URL.revokeObjectURL(url); },
        err=>{ console.error(err); msg('√âchec chargement image.'); URL.revokeObjectURL(url); }
      );
    };

    // Resize
    window.addEventListener('resize', fitCanvasToStage);
  }

  function draw(){
    fitCanvasToStage();

    background(negative?255:0);
    strokeWeight(parseFloat(ui.stroke.value));
    noFill();

    let pix=null, w=0, h=0;
    if (useCamera && cam && cam.width>0){
      cam.loadPixels();
      pix = cam.pixels; w=cam.width; h=cam.height;
    } else if (!useCamera && (imgScaled || img)){
      const srcImg = imgScaled || img;
      srcImg.loadPixels();
      pix = srcImg.pixels; w=srcImg.width; h=srcImg.height;
    } else {
      msg('Clique sur ‚ÄúActiver la cam√©ra‚Äù ou charge une image.');
      return;
    }

    const detail = Math.max(1, parseInt(ui.detail.value));
    const rw = parseFloat(ui.red.value), gw=parseFloat(ui.green.value), bw=parseFloat(ui.blue.value);
    const contrast = parseFloat(ui.contrast.value);
    const intensity = parseFloat(ui.intensity.value);
    const sens = parseFloat(ui.sensitivity.value);
    const diag = parseFloat(ui.diagonal.value);
    const circ = parseFloat(ui.circular.value);

    if (animate) animationOffset += 0.05;

    for (let x = 1; x < w-1; x += detail){
      for (let y = 1; y < h-1; y++){
        const i = (x + y*w)*4;
        const r = pix[i], g = pix[i+1], b = pix[i+2];
        const br = r*rw + g*gw + b*bw;

        const i1 = (x+1 + y*w)*4, i2 = (x-1 + y*w)*4;
        const i3 = (x + (y+1)*w)*4, i4 = (x + (y-1)*w)*4;
        const dx = (pix[i1]*rw + pix[i1+1]*gw + pix[i1+2]*bw) - (pix[i2]*rw + pix[i2+1]*gw + pix[i2+2]*bw);
        const dy = (pix[i3]*rw + pix[i3+1]*gw + pix[i3+2]*bw) - (pix[i4]*rw + pix[i4+1]*gw + pix[i4+2]*bw);
        const curve = (dx*dx + dy*dy) * sens;
        const offset = map(curve, 0, 255*255, -intensity, intensity);

        const baseX = map(x, 0, w, 0, width);
        const baseY = map(y, 0, h, 0, height);
        const xDraw = baseX + offset + diag * (y - h/2) * 0.3;
        const yDraw = baseY + offset + circ * Math.sin(dist(x,y,w/2,h/2)*0.1 + animationOffset) * 5.0;

        setStrokeColor(br, negative);
        if (br > contrast) point(xDraw, yDraw);
      }
    }
  }

  function paletteColors(){
    const cols=[];
    if (el('cR').checked) cols.push(color(255,40,40));
    if (el('cV').checked) cols.push(color(40,220,120));
    if (el('cB').checked) cols.push(color(40,140,255));
    if (el('cJ').checked) cols.push(color(255,210,40));
    return cols;
  }

  function setStrokeColor(br, negativeMode){
    const cols = paletteColors();
    if (cols.length===0){ stroke(negativeMode?0:255); return; }
    const idx = Math.min(cols.length-1, Math.floor(map(br,0,255,0,cols.length)));
    const c = cols[idx];
    if (!negativeMode) stroke(c);
    else stroke(255-red(c), 255-green(c), 255-blue(c));
  }
</script>
</body>
</html>

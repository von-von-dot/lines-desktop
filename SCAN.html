<!DOCTYPE html>
<!-- saved from url=(0036)https://von-von-dot.github.io/lines/ -->
<html lang="fr"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Scanlines Mobile ‚Äî points (qualit√© optimis√©e)</title>
  <style>
    :root{--gap:10px;--ui:#111;--card:#1a1a1a}
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:#000;color:#fff;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #wrap{display:flex;flex-direction:column;min-height:100dvh}
    #controls{height:34vh;overflow:auto;background:var(--ui);padding:var(--gap);display:flex;flex-wrap:wrap;gap:var(--gap);justify-content:center;align-content:flex-start}
    .card{background:var(--card);border-radius:12px;padding:8px;display:flex;flex-direction:column;align-items:center;gap:6px}
    .row{display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center}
    label{font-size:12px;opacity:.9}
    input[type="range"]{width:120px}
    button,.chip{background:#222;color:#fff;border:1px solid #333;border-radius:10px;padding:8px 12px;font-size:14px}
    .chip{display:inline-flex;gap:8px;align-items:center}
    #stage{height:66vh;display:flex;align-items:center;justify-content:center;background:#000;position:relative}
    canvas{max-width:100%;height:100%;display:block}
    #msg{position:absolute;color:#777}
  </style>
</head>
<body>
<div id="wrap">
  <!-- MENU / CONTROLS (top 1/3) -->
  <div id="controls">
    <div class="row" style="width:100%;justify-content:center">
      <span class="chip">Source :
        <label><input type="radio" name="src" id="srcCam" checked=""> Cam√©ra</label>
        <label><input type="radio" name="src" id="srcImg"> Image</label>
      </span>
      <button id="switchBtn">üîÑ Switch cam√©ra</button>
      <label class="chip">üì∑ Charger une image<input id="fileInput" type="file" accept="image/*" style="display:none"></label>
      <button id="saveBtn">üì∏ Enregistrer</button>
      <label class="chip"><input type="checkbox" id="animate"> üéûÔ∏è Animation</label>
      <label class="chip"><input type="checkbox" id="negative"> üåì N√©gatif</label>
      <span class="chip">Palette :
        <label><input type="checkbox" id="cR" checked=""> Rouge</label>
        <label><input type="checkbox" id="cV"> Vert</label>
        <label><input type="checkbox" id="cB"> Bleu</label>
        <label><input type="checkbox" id="cJ"> Jaune</label>
      </span>
    </div>
    <div class="row">
      <div class="card"><label>Contraste</label><input id="contrast" type="range" min="0" max="255" value="110"></div>
      <div class="card"><label>Intensit√©</label><input id="intensity" type="range" min="0" max="20" step="0.1" value="6"></div>
      <div class="card"><label>Sensibilit√©</label><input id="sensitivity" type="range" min="0.1" max="10" step="0.1" value="1.2"></div>
      <div class="card"><label>D√©tail</label><input id="detail" type="range" min="1" max="8" value="2"></div>
      <div class="card"><label>√âpaisseur</label><input id="stroke" type="range" min="0.5" max="8" step="0.1" value="1.2"></div>
      <div class="card"><label>Rouge</label><input id="red" type="range" min="0" max="1" step="0.01" value="0.2126"></div>
      <div class="card"><label>Vert</label><input id="green" type="range" min="0" max="1" step="0.01" value="0.7152"></div>
      <div class="card"><label>Bleu</label><input id="blue" type="range" min="0" max="1" step="0.01" value="0.0722"></div>
      <div class="card"><label>Points (fix√© √† 1)</label><input id="points" type="range" min="1" max="1" step="1" value="1" disabled=""></div>
      <div class="card"><label>Diagonale</label><input id="diagonal" type="range" min="0" max="1" step="0.01" value="0"></div>
      <div class="card"><label>Circulaire</label><input id="circular" type="range" min="0" max="1" step="0.01" value="0"></div>
    </div>
  </div>

  <!-- IMAGE ZONE (bottom 2/3) -->
  <div id="stage"><div id="msg"></div><canvas id="defaultCanvas0" class="p5Canvas" width="1512" height="530" style="width: 1512px; height: 530px;"></canvas></div>
</div>

<script src="./Scanlines Mobile ‚Äî points (qualiteÃÅ optimiseÃÅe)_files/p5.min.js"></script>
<script>
  let cam=null, img=null, imgScaled=null;
  let useCamera = true;
  let facing = "environment";
  let animate=false, negative=false, animationOffset=0;
  const ui={};

  // R√©glages de qualit√© / perf
  const CAM_TARGET = { w: 480, h: 360 };       // ‚Üë plus fin que 320x240
  const IMG_MAX   = { w: 720, h: 540 };        // ‚Üì limite les images import√©es

  const el = id => document.getElementById(id);

  function startCamera(){
    if (cam) { cam.remove(); cam=null; }
    try {
      cam = createCapture({ video: { facingMode: { exact: facing }, width: {ideal:640}, height:{ideal:480} }, audio:false });
    } catch(e) {
      cam = createCapture({ video: { facingMode: facing }, audio:false });
    }
    cam.elt.setAttribute('playsinline','');
    cam.elt.muted = true;
    cam.size(CAM_TARGET.w, CAM_TARGET.h);
    cam.hide();
  }

  function resampleImage(source){
    // Redimensionne l'image import√©e pour rester fluide
    const ratio = Math.min(IMG_MAX.w / source.width, IMG_MAX.h / source.height, 1);
    const w = Math.max(1, Math.floor(source.width * ratio));
    const h = Math.max(1, Math.floor(source.height * ratio));
    const g = createGraphics(w, h);
    g.image(source, 0, 0, w, h);
    return g.get(); // renvoie un p5.Image pr√™t pour loadPixels()
  }

  // NEW: keep source aspect ratio and fit canvas inside #stage (contain)
  function fitCanvasToStage(){
    const stage = el('stage');
    const maxW = stage.clientWidth;
    const maxH = stage.clientHeight;

    // get source aspect ratio (prefer camera > image > fallback 4:3)
    let sw = 4, sh = 3;
    if (useCamera && cam && cam.width && cam.height){ sw = cam.width; sh = cam.height; }
    else if (!useCamera && (imgScaled || img)){
      const s = imgScaled || img; sw = s.width; sh = s.height;
    }
    const aspect = sw / sh;

    // contain fit
    let targetW = maxW;
    let targetH = Math.round(maxW / aspect);
    if (targetH > maxH){ targetH = maxH; targetW = Math.round(maxH * aspect); }

    // apply only if changed
    if (width !== targetW || height !== targetH){
      resizeCanvas(targetW, targetH, false);
    }
  }

  function setup(){
    pixelDensity(1);
    const stage = el('stage');
    const c = createCanvas(stage.clientWidth, stage.clientHeight);
    c.parent('stage');
    background(0);
    startCamera();

    // Bind UI
    ['contrast','intensity','sensitivity','detail','stroke','red','green','blue','points','diagonal','circular'].forEach(id=>ui[id]=el(id));
    el('saveBtn').onclick = ()=>saveCanvas('scan_mobile_points','png');
    el('switchBtn').onclick = ()=>{ facing = (facing==='user')?'environment':'user'; if(useCamera) startCamera(); };
    el('animate').onchange = e=> animate=e.target.checked;
    el('negative').onchange = e=> negative=e.target.checked;
    el('srcCam').onchange = e=>{ if(e.target.checked){ useCamera=true; startCamera(); } };
    el('srcImg').onchange = e=>{ if(e.target.checked){ useCamera=false; if(cam){cam.remove(); cam=null;} } };
    el('fileInput').onchange = (e)=>{
      const f = e.target.files[0]; if(!f) return;
      const url = URL.createObjectURL(f);
      loadImage(url, i=>{ img=i; imgScaled=resampleImage(img); el('srcImg').checked=true; el('srcCam').checked=false; useCamera=false; el('msg').textContent=''; fitCanvasToStage(); });
    };

    // Resize
    window.addEventListener('resize', fitCanvasToStage);
  }

  function draw(){
    // ensure canvas respects source aspect each frame (covers camera ready late)
    fitCanvasToStage();

    background(negative?255:0);
    strokeWeight(parseFloat(ui.stroke.value));
    noFill();

    // source + buffer pixels
    let pix=null, w=0, h=0;
    if (useCamera && cam && cam.width>0){
      el('msg').textContent='';
      cam.loadPixels();
      pix = cam.pixels; w=cam.width; h=cam.height;
    } else if (!useCamera && (imgScaled || img)){
      const srcImg = imgScaled || img;
      srcImg.loadPixels();
      pix = srcImg.pixels; w=srcImg.width; h=srcImg.height;
    } else {
      return;
    }

    const detail = Math.max(1, parseInt(ui.detail.value));
    const rw = parseFloat(ui.red.value), gw=parseFloat(ui.green.value), bw=parseFloat(ui.blue.value);
    const contrast = parseFloat(ui.contrast.value);
    const intensity = parseFloat(ui.intensity.value);
    const sens = parseFloat(ui.sensitivity.value);
    const diag = parseFloat(ui.diagonal.value);
    const circ = parseFloat(ui.circular.value);

    if (animate) animationOffset += 0.05;

    // Dessin par points (pas de lignes)
    for (let x = 1; x < w-1; x += detail){
      for (let y = 1; y < h-1; y++){
        const i = (x + y*w)*4;
        const r = pix[i], g = pix[i+1], b = pix[i+2];
        const br = r*rw + g*gw + b*bw;

        const i1 = (x+1 + y*w)*4, i2 = (x-1 + y*w)*4;
        const i3 = (x + (y+1)*w)*4, i4 = (x + (y-1)*w)*4;
        const dx = (pix[i1]*rw + pix[i1+1]*gw + pix[i1+2]*bw) - (pix[i2]*rw + pix[i2+1]*gw + pix[i2+2]*bw);
        const dy = (pix[i3]*rw + pix[i3+1]*gw + pix[i3+2]*bw) - (pix[i4]*rw + pix[i4+1]*gw + pix[i4+2]*bw);
        const curve = (dx*dx + dy*dy) * sens;
        const offset = map(curve, 0, 255*255, -intensity, intensity);

        const baseX = map(x, 0, w, 0, width);
        const baseY = map(y, 0, h, 0, height);
        const xDraw = baseX + offset + diag * (y - h/2) * 0.3;
        const yDraw = baseY + offset + circ * Math.sin(dist(x,y,w/2,h/2)*0.1 + animationOffset) * 5.0;

        setStrokeColor(br, negative);
        if (br > contrast) point(xDraw, yDraw);
      }
    }
  }

  function paletteColors(){
    const cols=[];
    if (el('cR').checked) cols.push(color(255,40,40));
    if (el('cV').checked) cols.push(color(40,220,120));
    if (el('cB').checked) cols.push(color(40,140,255));
    if (el('cJ').checked) cols.push(color(255,210,40));
    return cols;
  }

  function setStrokeColor(br, negativeMode){
    const cols = paletteColors();
    if (cols.length===0){ stroke(negativeMode?0:255); return; }
    const idx = Math.min(cols.length-1, Math.floor(map(br,0,255,0,cols.length)));
    const c = cols[idx];
    if (!negativeMode) stroke(c);
    else stroke(255-red(c), 255-green(c), 255-blue(c));
  }
</script>


<main></main><video playsinline="" crossorigin="anonymous" width="480" height="360" style="width: 480px; height: 360px; display: none;"></video></body></html>
